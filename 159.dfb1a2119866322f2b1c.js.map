{"version":3,"file":"159.dfb1a2119866322f2b1c.js","mappings":"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","sources":["webpack://@filimon/sudoku/./src/sudoku/grader/Rating.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/LastCell.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/Slotting.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/NakedSingles.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/HiddenSingles.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/PointingCandidates.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/NakedTuples.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/BoxLineReduction.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/HiddenTuples.ts","webpack://@filimon/sudoku/./src/sudoku/grader/strategies/XWing.ts","webpack://@filimon/sudoku/./src/sudoku/grader/Grader.ts","webpack://@filimon/sudoku/./src/sudoku/model/SudokuCell.ts","webpack://@filimon/sudoku/./src/sudoku/model/SudokuSet.ts","webpack://@filimon/sudoku/./src/sudoku/model/Sudoku.ts","webpack://@filimon/sudoku/./src/workers/puzzle-grader.worker.ts"],"sourcesContent":["export enum Rating {\n  Unrated = 0,\n  Easy = 1,\n  Moderate = 2,\n  Hard = 3,\n  Extreme = 4,\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\nimport { SudokuCell } from '../../model/SudokuCell';\n\n/**\n * A simple strategy that does not require notes.\n *\n * The strategy looks at each set and checks if only a single number is missing from that set.\n * If only a single number is missing in a set it follows that it has to be the solution for the empty cell.\n */\nexport class LastCell implements IStrategy {\n  get rating() {\n    return Rating.Easy;\n  }\n\n  run(sudoku: Sudoku) {\n    const sets = [...sudoku.blocks, ...sudoku.rows, ...sudoku.columns];\n    for (let i = 0; i < sets.length; i++) {\n      const set = sets[i];\n      const missingNumber = set.missingNumbers;\n      if (missingNumber.length === 1) {\n        const cell = set.cells.find((cell) => !cell.value) as SudokuCell;\n        cell.value = missingNumber[0];\n        return {\n          changed: true,\n          description: `<last cell> The cell at row ${cell.row.index + 1} and column ${cell.column.index + 1} is the last empty cell of ${set.type} ${set.index + 1} and has to be the missing number ${missingNumber}.`,\n        };\n      }\n    }\n    return { changed: false };\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\n\n/**\n * A simple strategy that does not require notes.\n * The strategy looks at blocks the values in the lines that affect that block.\n *\n * A value is considered to be slotted into an empty cell when no other empty cell\n * in the block can take the value since one of the affecting lines contains that value.\n */\nexport class Slotting implements IStrategy {\n  get rating() {\n    return Rating.Easy;\n  }\n\n  run(sudoku: Sudoku) {\n    for (let blockIndex = 0; blockIndex < sudoku.blocks.length; blockIndex++) {\n      const block = sudoku.blocks[blockIndex];\n      if (block.cells.every((cell) => !!cell.value)) {\n        continue;\n      }\n      const emptyCellsInBlock = block.cells.filter((cell) => !cell.value);\n\n      for (let emptyIndex = 0; emptyIndex < emptyCellsInBlock.length; emptyIndex++) {\n        const emptyCell = emptyCellsInBlock[emptyIndex];\n        const missingNumbers = block.missingNumbers;\n        for (let missingIndex = 0; missingIndex < missingNumbers.length; missingIndex++) {\n          const missingNumber = missingNumbers[missingIndex];\n          const otherEmptyCellsInBLock = emptyCellsInBlock.filter((c) => c !== emptyCell);\n\n          /**\n           * This calculates that every other empty cell in the block can't have the missing value.\n           * It does this by veryfying that the other cell is part of either a column\n           * or row that already has the missing value in it, and thus could not have the missing value.\n           *\n           * Since no other cell can have the value it has to be the solution for this empty cell.\n           */\n          const isMissingNumberSlotted = otherEmptyCellsInBLock.every((c) =>\n            [...c.row.cells, ...c.column.cells].some((c) => c.value === missingNumber)\n          );\n\n          if (isMissingNumberSlotted) {\n            emptyCell.value = missingNumber;\n            return {\n              changed: true,\n              description: `All other cells in the block apart from target cell have number ${missingNumber} in either a row or column so the target cell is the only alternative for ${missingNumber}. `,\n            };\n          }\n        }\n      }\n    }\n    return { changed: false };\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\n\nexport class NakedSingles implements IStrategy {\n  get rating() {\n    return Rating.Easy;\n  }\n\n  run(sudoku: Sudoku) {\n    for (let cellIndex = 0; cellIndex < sudoku.cells.length; cellIndex++) {\n      const cell = sudoku.cells[cellIndex];\n      if (cell.candidates.length === 1) {\n        cell.value = cell.candidates[0];\n        return { changed: true, description: 'naked singles' };\n      }\n    }\n    return { changed: false };\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\n\nexport class HiddenSingles implements IStrategy {\n  get rating() {\n    return Rating.Moderate;\n  }\n\n  run(sudoku: Sudoku) {\n    const sets = [...sudoku.blocks, ...sudoku.rows, ...sudoku.columns];\n    for (let setIndex = 0; setIndex < sets.length; setIndex++) {\n      const set = sets[setIndex];\n      const missingNumbers = set.missingNumbers;\n      for (let missingNumberIndex = 0; missingNumberIndex < missingNumbers.length; missingNumberIndex++) {\n        const missingNumber = missingNumbers[missingNumberIndex];\n        const possibleCells = set.cells.filter((cell) => cell.candidates.includes(missingNumber));\n        if (possibleCells.length === 1) {\n          possibleCells[0].value = missingNumber;\n          return { changed: true, description: 'hidden singles' };\n        }\n      }\n    }\n    return { changed: false };\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { SudokuSet } from '../../model/SudokuSet';\nimport { IStrategy } from './IStrategy';\n\n/**\n * This strategy requires notes as it eliminates candidates\n * from lines based on the position of missing numbers in a block.\n *\n * If a block can only contain a missing number in a row or column they can't\n * be present in the rest of that line.\n * We could thus remove the missing number from then candidates of that line that are not in the same block.\n */\nexport class PointingCandidates implements IStrategy {\n  get rating() {\n    return Rating.Moderate;\n  }\n\n  run(sudoku: Sudoku) {\n    const blocks = sudoku.blocks;\n    for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n      const block = blocks[blockIndex];\n      const emptyCells = block.cells.filter((cell) => !cell.value);\n      const missingNumbers = block.missingNumbers;\n      for (let missingIndex = 0; missingIndex < missingNumbers.length; missingIndex++) {\n        const missing = missingNumbers[missingIndex];\n        const availableCells = emptyCells.filter((cell) => cell.candidates.includes(missing));\n        const affectedRows = Array.from(new Set(availableCells.map((cell) => cell.row)));\n        const affectedColumns = Array.from(new Set(availableCells.map((cell) => cell.column)));\n\n        const simplify = (affectedCells: SudokuSet[]) => {\n          let dirty = false;\n          if (affectedCells.length === 1) {\n            const cells = affectedCells[0].cells;\n            for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n              const cell = cells[cellIndex];\n              if (cell.block !== block) {\n                const removeIndex = cell.candidates.indexOf(missing);\n                if (removeIndex !== -1) {\n                  cell.candidates.splice(removeIndex, 1);\n                  dirty = true;\n                }\n              }\n            }\n          }\n          return dirty;\n        };\n\n        if (simplify(affectedRows)) {\n          return { changed: true, description: 'pointing candidates' };\n        }\n        // Only check columns if rows did not alter candidates\n        if (simplify(affectedColumns)) {\n          return { changed: true, description: 'pointing candidates' };\n        }\n      }\n    }\n    return { changed: false };\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\n\nexport class NakedTuples implements IStrategy {\n  get rating() {\n    return Rating.Moderate;\n  }\n\n  #size: 2 | 3 | 4;\n\n  constructor(size: 2 | 3 | 4) {\n    this.#size = size;\n  }\n\n  run(sudoku: Sudoku) {\n    const sets = [...sudoku.blocks, ...sudoku.rows, ...sudoku.columns];\n\n    for (let setIndex = 0; setIndex < sets.length; setIndex++) {\n      const set = sets[setIndex];\n      const cells = set.cells.filter((cell) => cell.candidates.length > 0);\n      const combinations = this.#combine(cells, this.#size);\n\n      for (let combinationIndex = 0; combinationIndex < combinations.length; combinationIndex++) {\n        const combination = combinations[combinationIndex];\n        if (combination.length === this.#size) {\n          const candidates = Array.from(new Set(combination.flatMap((cell) => cell.candidates)));\n          if (candidates.length === this.#size) {\n            let dirty = false;\n            let description = 'naked tuples';\n\n            candidates.forEach((candidate) => {\n              const others = set.cells.filter(\n                (cell) => cell.candidates.includes(candidate) && !combination.includes(cell)\n              );\n              others.forEach((cell) => {\n                const removeIndex = cell.candidates.indexOf(candidate);\n                if (removeIndex !== -1) {\n                  cell.candidates.splice(removeIndex, 1);\n                  description += ` | removing candidate ${candidate} in cell (${cell.row.index + 1}, ${cell.column.index + 1}))`;\n                  dirty = true;\n                }\n              });\n            });\n            if (dirty) {\n              return { changed: true, description };\n            }\n          }\n        }\n      }\n    }\n\n    return { changed: false };\n  }\n\n  #combine<T>(alternatives: T[], size: number): T[][] {\n    if (size === 1) {\n      return alternatives.map((alternative) => [alternative]);\n    }\n\n    return alternatives.flatMap((alternative, index) =>\n      this.#combine(alternatives.slice(index + 1), size - 1).map((z) => [alternative, ...z])\n    );\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { SudokuSet } from '../../model/SudokuSet';\nimport { IStrategy } from './IStrategy';\n\n/**\n * This strategy requires notes as it eliminates candidates\n * from boxes based on the position of missing numbers in lines that block.\n *\n * If all the missing numbers of a line are in the same block then no other cells in that block\n * can have those missings numbers as candidates.\n * We could thus remove the missing number from then candidates of that box that are not in the same line.\n */\nexport class BoxLineReduction implements IStrategy {\n  get rating() {\n    return Rating.Moderate;\n  }\n\n  run(sudoku: Sudoku) {\n    const lines = [...sudoku.rows, ...sudoku.columns];\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      const line = lines[lineIndex];\n      const missingNumbers = line.missingNumbers;\n      for (let missingIndex = 0; missingIndex < missingNumbers.length; missingIndex++) {\n        const missingNumber = missingNumbers[missingIndex];\n\n        const blocks = line.cells.reduce((result, cell) => {\n          if (cell.candidates.includes(missingNumber)) {\n            result.add(cell.block);\n          }\n          return result;\n        }, new Set<SudokuSet>());\n\n        if (blocks.size === 1) {\n          const block = Array.from(blocks)[0];\n          const cellsToUpdateInBlock = block.cells.filter(\n            (cell) => cell.candidates.includes(missingNumber) && !line.cells.includes(cell)\n          );\n          let dirty = false;\n          for (let cellIndex = 0; cellIndex < cellsToUpdateInBlock.length; cellIndex++) {\n            const cell = cellsToUpdateInBlock[cellIndex];\n            const candidateIndex = cell.candidates.indexOf(missingNumber);\n            if (candidateIndex !== -1) {\n              cell.candidates.splice(candidateIndex, 1);\n              dirty = true;\n            }\n          }\n          if (dirty) {\n            return { changed: true, description: 'box/line reduction' };\n          }\n        }\n      }\n    }\n    return { changed: false };\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst types = {\n  2: 'doubles',\n  3: 'tripplets',\n  4: 'quadrouples',\n};\n\nexport class HiddenTuples implements IStrategy {\n  get rating() {\n    return Rating.Hard;\n  }\n\n  #size: 2 | 3 | 4;\n\n  constructor(size: 2 | 3 | 4) {\n    this.#size = size;\n  }\n\n  run(sudoku: Sudoku) {\n    const sets = [...sudoku.blocks, ...sudoku.rows, ...sudoku.columns];\n    sets.forEach((set) => {\n      const missingNumbers = set.missingNumbers;\n      const combinations = this.#combine(missingNumbers, this.#size);\n      combinations.forEach((combination) => {\n        const candidateCells = set.cells.filter(\n          (cell) => cell.candidates.length > 0 && cell.candidates.some((candidate) => combination.includes(candidate))\n        );\n        if (candidateCells.length === this.#size) {\n          const cover = new Set(candidateCells.flatMap((cell) => cell.candidates));\n          if (combination.every((value) => cover.has(value))) {\n            combination.forEach((candidate) => {\n              const affectedCells = set.cells.filter(\n                (cell) => !candidateCells.includes(cell) && cell.candidates.length > 0\n              );\n              affectedCells.forEach((cell) => {\n                const removeIndex = cell.candidates.indexOf(candidate);\n                if (removeIndex !== -1) {\n                  cell.candidates.splice(removeIndex, 1);\n                  return { changed: true, descprition: 'hidden tupples' };\n                }\n              });\n            });\n          }\n        }\n      });\n    });\n    return { changed: false };\n  }\n\n  #combine<T>(alternatives: T[], size: number): T[][] {\n    if (size === 1) {\n      return alternatives.map((alternative) => [alternative]);\n    }\n\n    return alternatives.flatMap((alternative, index) =>\n      this.#combine(alternatives.slice(index + 1), size - 1).map((z) => [alternative, ...z])\n    );\n  }\n}\n","import { Rating } from '../Rating';\nimport { Sudoku } from '../../model/Sudoku';\nimport { IStrategy } from './IStrategy';\n\n// rows: 005000400020940000900700008003000290100203007079000300400008001000014060006000700\n// columns: 003910700000003400100040006060700000002109600000002010700080003008200000005071900\n\nexport class XWing implements IStrategy {\n  get rating() {\n    return Rating.Hard;\n  }\n\n  run(sudoku: Sudoku) {\n    const rowResult = this.#run(sudoku, 'rows');\n    if (rowResult.changed) {\n      return rowResult;\n    }\n    return this.#run(sudoku, 'columns');\n  }\n\n  // TODO: optimize\n  // TODO: generalize to swordfish\n  #run(sudoku: Sudoku, direction: 'rows' | 'columns') {\n    const lines = sudoku[direction];\n    const opposite = direction === 'rows' ? 'column' : 'row';\n    const same = direction === 'rows' ? 'row' : 'column';\n    for (let value = 1; value <= 9; value++) {\n      const linesWithTwoCandidateCells = lines.filter(\n        (line) => line.cells.filter((cell) => cell.candidates.includes(value)).length == 2\n      );\n      for (const line of linesWithTwoCandidateCells) {\n        const candidateCells = line.cells.filter((cell) => cell.candidates.includes(value));\n        const otherLine = linesWithTwoCandidateCells.find((otherLine) => {\n          if (line !== otherLine) {\n            const otherCandidateCells = otherLine.cells.filter((cell) => cell.candidates.includes(value));\n            return candidateCells.every(\n              (cell, index) => cell[opposite].index === otherCandidateCells[index][opposite].index\n            );\n          }\n          return false;\n        });\n        if (otherLine) {\n          const cellsToUpdate = candidateCells\n            .flatMap((cell) => cell[opposite].cells)\n            .filter((cell) => {\n              return cell[same] !== line && cell[same] !== otherLine && cell.candidates.includes(value);\n            });\n          if (cellsToUpdate.length) {\n            for (const cell of cellsToUpdate) {\n              cell.candidates.splice(cell.candidates.indexOf(value), 1);\n            }\n            return { changed: true, description: 'xwing' };\n          }\n        }\n      }\n    }\n\n    return { changed: false };\n  }\n}\n","import { Sudoku } from '../model/Sudoku';\nimport { LastCell } from './strategies/LastCell';\nimport { Rating as RATING } from './Rating';\nimport { Slotting } from './strategies/Slotting';\nimport { NakedSingles } from './strategies/NakedSingles';\nimport { HiddenSingles } from './strategies/HiddenSingles';\nimport { PointingCandidates } from './strategies/PointingCandidates';\nimport { NakedTuples } from './strategies/NakedTuples';\nimport { BoxLineReduction } from './strategies/BoxLineReduction';\nimport { HiddenTuples } from './strategies/HiddenTuples';\nimport { XWing } from './strategies/XWing';\n\ntype strategy = LastCell;\n// x-wing  007010000000800500180009064600000003071080640400000005840600031005002000000030700\nexport class Grader {\n  grade(sudoku: Sudoku) {\n    return this.#solve(sudoku, [\n      new LastCell(),\n      new Slotting(),\n      new NakedSingles(),\n      new HiddenSingles(),\n      new NakedTuples(2),\n      new NakedTuples(3),\n      new PointingCandidates(),\n      new HiddenTuples(2),\n      new HiddenTuples(3),\n      new BoxLineReduction(),\n      new NakedTuples(4),\n      new HiddenTuples(4),\n      new XWing(),\n    ]);\n  }\n\n  #getSnapshot(sudoku: Sudoku) {\n    return sudoku.cells.map((cell) => ({\n      value: cell.value ? cell.value.toString() : '',\n      candidates: cell.candidates.map((x) => x.toString()),\n    }));\n  }\n\n  #solve(sudoku: Sudoku, strategies: strategy[]) {\n    let highestRating = RATING.Unrated;\n    let strategyIndex = 0;\n    const steps = [\n      {\n        description: 'Initial',\n        snapshot: this.#getSnapshot(sudoku),\n      },\n    ] as { description: string; snapshot: { value: string; candidates: string[] }[] }[];\n    while (true) {\n      const strategy = strategies[strategyIndex];\n      const { changed, description } = strategy.run(sudoku);\n      // const sets = [...sudoku.blocks, ...sudoku.rows, ...sudoku.columns];\n      // if (\n      //   sets.some((set) => {\n      //     const solved = set.cells.filter((cell) => cell.value);\n      //     if (solved.length === 9) {\n      //       const unique = new Set(solved.map((cell) => cell.value));\n      //       if (unique.size !== 9) {\n      //         return true;\n      //       }\n      //     }\n      //     return false;\n      //   })\n      // ) {\n      //   throw new Error('fucky');\n      // }\n      if (changed) {\n        steps.push({\n          description: description ?? '',\n          snapshot: this.#getSnapshot(sudoku),\n        });\n        highestRating = Math.max(highestRating, strategy.rating);\n        // Make sure we always try the easiest solution first.\n        strategyIndex = 0;\n      } else {\n        strategyIndex++;\n        if (strategyIndex >= strategies.length) {\n          break;\n        }\n      }\n      if (sudoku.emptyCells.length === 0) {\n        steps.push({\n          description: description ?? '',\n          snapshot: this.#getSnapshot(sudoku),\n        });\n        break;\n      }\n    }\n\n    const isSolved = sudoku.emptyCells.length === 0;\n    if (isSolved) {\n      return {\n        grade: highestRating,\n        steps,\n      };\n    }\n    return {\n      grade: RATING.Extreme,\n      steps,\n    };\n  }\n}\n","import { SudokuSet } from './SudokuSet';\n\nexport class SudokuCell {\n  candidates: number[] = [];\n  #value: number | null = null;\n\n  get value(): number | null {\n    return this.#value;\n  }\n  set value(val: number | null) {\n    if (val !== null) {\n      Array.from(new Set([...this.block.cells, ...this.row.cells, ...this.column.cells]))\n        .filter((cell) => !cell.value && cell !== this)\n        .forEach((cell) => {\n          const candidateIndex = cell.candidates.indexOf(val);\n          if (candidateIndex !== -1) {\n            cell.candidates.splice(candidateIndex, 1);\n          }\n        });\n      this.candidates = [];\n    }\n    this.#value = val;\n  }\n  block: SudokuSet;\n  row: SudokuSet;\n  column: SudokuSet;\n\n  constructor(block: SudokuSet, row: SudokuSet, column: SudokuSet, value: number = 0) {\n    this.block = block;\n    this.row = row;\n    this.column = column;\n    this.candidates = [];\n    this.#value = value === 0 ? null : value;\n  }\n\n  calculateCandidates() {\n    if (this.value) {\n      return;\n    }\n    const result = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    const influencers = Array.from(\n      new Set(\n        [...this.block.cells, ...this.row.cells, ...this.column.cells].filter(\n          (cell) => cell !== this && !!cell.value\n        ) as SudokuCell[]\n      )\n    );\n    influencers.forEach((cell) => result.delete(cell.value as number));\n    this.candidates = Array.from(result);\n  }\n}\n","import { SudokuCell } from './SudokuCell';\n\ntype typeOptions = 'row' | 'column' | 'block';\n\nexport class SudokuSet {\n  cells: SudokuCell[];\n  index: number;\n  type: typeOptions;\n\n  constructor(index: number, type: typeOptions) {\n    this.cells = [];\n    this.index = index;\n    this.type = type;\n  }\n\n  add(cell: SudokuCell) {\n    this.cells.push(cell);\n  }\n\n  get missingNumbers(): number[] {\n    const result = [] as number[];\n    for (let value = 1; value <= 9; value++) {\n      if (this.cells.every((cell) => cell.value !== value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n}\n","import { SudokuCell } from './SudokuCell';\nimport { SudokuSet } from './SudokuSet';\n\nexport class Sudoku {\n  blocks: SudokuSet[];\n  rows: SudokuSet[];\n  columns: SudokuSet[];\n  cells: SudokuCell[];\n\n  constructor(cells: string) {\n    const rawRows = cells.split('').reduce(\n      (result, next) => {\n        if (result.at(-1)?.length === 9) {\n          result.push([]);\n        }\n        result.at(-1)?.push(+next);\n        return result;\n      },\n      [[]] as number[][]\n    );\n\n    this.blocks = [];\n    this.rows = [];\n    this.columns = [];\n    this.cells = [];\n\n    for (let rowIndex = 0; rowIndex < 9; rowIndex++) {\n      const cells = rawRows[rowIndex];\n      this.rows[rowIndex] = this.rows[rowIndex] || new SudokuSet(rowIndex, 'row');\n\n      for (let columnIndex = 0; columnIndex < 9; columnIndex++) {\n        this.columns[columnIndex] = this.columns[columnIndex] || new SudokuSet(columnIndex, 'column');\n        // ~~ faster than Math.floor?\n        const blockIndex = ~~(rowIndex / 3) * 3 + ~~(columnIndex / 3);\n\n        this.blocks[blockIndex] = this.blocks[blockIndex] || new SudokuSet(blockIndex, 'block');\n\n        const ratedCell = new SudokuCell(\n          this.blocks[blockIndex],\n          this.rows[rowIndex],\n          this.columns[columnIndex],\n          cells[columnIndex]\n        );\n        this.cells.push(ratedCell);\n        this.blocks[blockIndex].add(ratedCell);\n        this.rows[rowIndex].add(ratedCell);\n        this.columns[columnIndex].add(ratedCell);\n      }\n    }\n\n    this.cells.forEach((cell) => cell.calculateCandidates());\n  }\n\n  get emptyCells(): SudokuCell[] {\n    return this.cells.filter((cell) => !cell.value);\n  }\n}\n","import { Grader } from '../sudoku/grader/Grader';\nimport { Sudoku } from '../sudoku/model/Sudoku';\n\nself.onmessage = (event: { data: string }) => {\n  if (event.data.length === 81) {\n    run(event.data);\n  }\n};\n\nconst run = (puzzle: string) => {\n  const grader = new Grader();\n  const sudoku = new Sudoku(puzzle);\n  const { grade } = grader.grade(sudoku);\n  self.postMessage({\n    puzzle,\n    grade,\n  });\n};\n"],"names":["Rating","LastCell","rating","Easy","run","sudoku","sets","blocks","rows","columns","i","length","set","missingNumber","missingNumbers","cell","cells","find","value","changed","description","row","index","column","type","Slotting","blockIndex","block","every","emptyCellsInBlock","filter","emptyIndex","emptyCell","missingIndex","c","some","NakedSingles","cellIndex","candidates","HiddenSingles","Moderate","setIndex","missingNumberIndex","possibleCells","includes","PointingCandidates","emptyCells","missing","availableCells","affectedRows","Array","from","Set","map","affectedColumns","simplify","affectedCells","dirty","removeIndex","indexOf","splice","NakedTuples","constructor","size","this","combinations","combinationIndex","combination","flatMap","forEach","candidate","alternatives","alternative","slice","z","BoxLineReduction","lines","lineIndex","line","reduce","result","add","cellsToUpdateInBlock","candidateIndex","HiddenTuples","Hard","candidateCells","cover","has","descprition","XWing","rowResult","direction","opposite","same","linesWithTwoCandidateCells","otherLine","otherCandidateCells","cellsToUpdate","Grader","grade","toString","x","strategies","highestRating","Unrated","strategyIndex","steps","snapshot","strategy","push","Math","max","Extreme","SudokuCell","val","calculateCandidates","delete","SudokuSet","Sudoku","rawRows","split","next","at","rowIndex","columnIndex","ratedCell","self","onmessage","event","data","puzzle","grader","postMessage"],"sourceRoot":""}