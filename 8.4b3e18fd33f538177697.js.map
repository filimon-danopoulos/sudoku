{"version":3,"file":"8.4b3e18fd33f538177697.js","mappings":"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CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAIrBC,EAAgC,CACpC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GACpE,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EA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","sources":["webpack://@filimon/sudoku/./src/sudoku/validator/MatrixEntry.ts","webpack://@filimon/sudoku/./src/sudoku/validator/LinkedMatrix.ts","webpack://@filimon/sudoku/./src/sudoku/validator/Solver.ts","webpack://@filimon/sudoku/./src/sudoku/generator/Generator.ts","webpack://@filimon/sudoku/./src/workers/puzzle-generator.worker.ts"],"sourcesContent":["export default class MatrixEntry {\n  #size: number;\n  #left: MatrixEntry;\n  #right: MatrixEntry;\n  #up: MatrixEntry;\n  #down: MatrixEntry;\n  #x: number;\n  #y: number;\n\n  constructor(x: number, y: number) {\n    this.#size = 0;\n\n    this.#left = this;\n    this.#right = this;\n    this.#up = this;\n    this.#down = this;\n    this.#x = x;\n    this.#y = y;\n  }\n\n  get X(): number {\n    return this.#x;\n  }\n\n  get Y(): number {\n    return this.#y;\n  }\n\n  get Left(): MatrixEntry {\n    return this.#left;\n  }\n\n  get Right(): MatrixEntry {\n    return this.#right;\n  }\n\n  get Up(): MatrixEntry {\n    return this.#up;\n  }\n\n  get Down(): MatrixEntry {\n    return this.#down;\n  }\n\n  get Size(): number {\n    return this.#size;\n  }\n\n  incrementSize(): void {\n    ++this.#size;\n  }\n\n  decrementSize(): void {\n    --this.#size;\n  }\n\n  horizontalExclude(): void {\n    this.#left.#right = this.#right;\n    this.#right.#left = this.#left;\n  }\n\n  verticalExclude(): void {\n    this.#up.#down = this.#down;\n    this.#down.#up = this.#up;\n  }\n\n  horizontalInclude(): void {\n    this.#left.#right = this;\n    this.#right.#left = this;\n  }\n\n  verticalInclude(): void {\n    this.#up.#down = this;\n    this.#down.#up = this;\n  }\n\n  horizontalInsert(entry: MatrixEntry): void {\n    entry.#left = this.#left;\n    entry.#right = this;\n\n    this.#left.#right = entry;\n    this.#left = entry;\n  }\n\n  verticalInsert(entry: MatrixEntry): void {\n    entry.#up = this.#up;\n    entry.#down = this;\n\n    this.#up.#down = entry;\n    this.#up = entry;\n  }\n}\n","import MatrixEntry from './MatrixEntry';\n\n/**\n * A sparse matrix where each element is douply linked in both the row and column direction.\n */\nexport default class LinkedSparseMatrix {\n  #root: MatrixEntry;\n  #columnHeaders: MatrixEntry[];\n\n  constructor(data: boolean[][]) {\n    this.#root = new MatrixEntry(-1, -1);\n    this.#columnHeaders = [];\n    const sparseRepresentation = this.#convertDenseMatrixToSparseRepresentation(data);\n    this.#generateRows(sparseRepresentation);\n  }\n\n  getColumnIndexOf(columnHeader: MatrixEntry): number {\n    return this.#columnHeaders.indexOf(columnHeader);\n  }\n\n  get Root(): MatrixEntry {\n    return this.#root;\n  }\n\n  /**\n   * Converts matrix of ones and zeroes where most elements are\n   * zeroes, i.e. a sparse matrix to a representation where each element\n   * correponds to the index of a one. This greatly reduces the ammount\n   * of elements we are required to keep track of.\n   */\n  #convertDenseMatrixToSparseRepresentation(data: boolean[][]): number[][] {\n    return data.map(\n      (row) =>\n        row.reduce((sparse, value, index) => {\n          if (value) {\n            sparse.push(index);\n          }\n          return sparse;\n        }, [] as number[]),\n      [] as number[][]\n    );\n  }\n\n  /**\n   * All rows that have an entry at the provided column index are excluded from the linked matrix.\n   * They are not removed from the columns array so that they can be added gain.\n   * This is made possible by the way the data in structured. An entry is linked to a column\n   * header only if it has an entry in the corresponding column. By itterating through\n   * the Down link all rows can be found. All entries in the entrire row can then\n   * be found and excluded through the Right link.\n   */\n  cover(index: number): void {\n    const columnHeader = this.#columnHeaders[index];\n\n    columnHeader.horizontalExclude();\n    for (let row = columnHeader.Down; row !== columnHeader; row = row.Down) {\n      for (let entry = row.Right; entry !== row; entry = entry.Right) {\n        entry.verticalExclude();\n        this.#columnHeaders[entry.X].decrementSize();\n      }\n    }\n  }\n\n  /**\n   * All rows that have an entry at the provided column index are included in the linked matrix.\n   * The same approach is taken as in the cover method but the Up and Left are used instead.\n   * That way the original order is maintained.\n   */\n  uncover(index: number): void {\n    const columnHeader = this.#columnHeaders[index];\n\n    columnHeader.horizontalInclude();\n    for (let row = columnHeader.Up; row !== columnHeader; row = row.Up) {\n      for (let entry = row.Left; entry !== row; entry = entry.Left) {\n        entry.verticalInclude();\n        this.#columnHeaders[entry.X].incrementSize();\n      }\n    }\n  }\n\n  /**\n   * Creates each row of the data. Each row is built on temporary entry that is later removed.\n   * Each element in each row is also linked to a column. This methods makes sure that\n   * all required column headers exist. By linking the entries in both the row and column\n   * direction the time it takes to traverse the matrix to find ones is greatly reduced.\n   */\n  #generateRows(sparseRepresentation: number[][]) {\n    sparseRepresentation.forEach((dataRow, i) => {\n      const temporaryRowRoot = new MatrixEntry(-1, i);\n      dataRow.forEach((dataPoint) => {\n        const entry = new MatrixEntry(dataPoint, i);\n\n        if (this.#columnHeaders.length <= dataPoint) {\n          this.#appendColumnHeaders(dataPoint - this.#columnHeaders.length + 1);\n        }\n        const currentColumnHeader = this.#columnHeaders[dataPoint];\n        currentColumnHeader.verticalInsert(entry);\n        currentColumnHeader.incrementSize();\n        temporaryRowRoot.horizontalInsert(entry);\n      });\n      temporaryRowRoot.horizontalExclude();\n    });\n  }\n\n  /**\n   * Appends new MatrixEntries called headers (they are not part of the data).\n   * These linked to the root element, each element in a row is also part of a linked list that\n   * is based of a column header.\n   */\n  #appendColumnHeaders(count: number): void {\n    while (count--) {\n      const columnHeader = new MatrixEntry(this.#columnHeaders.length, -1);\n      this.#root.horizontalInsert(columnHeader);\n      this.#columnHeaders.push(columnHeader);\n    }\n  }\n}\n","import LinkedSparseMatrix from './LinkedMatrix';\nimport MatrixEntry from './MatrixEntry';\n\ntype metadata = {\n  row: number;\n  column: number;\n  block: number;\n  value: number;\n};\n\n/**\n * A solver that uses DLX to solve puzzles. It is expensive to initialize.\n * However it is stateless so once it has been initialized it can be be used to solve many puzzles.\n */\nexport class Solver {\n  #rowMetaData: metadata[];\n  #sudokuRuleMatrix: boolean[][];\n\n  constructor() {\n    this.#rowMetaData = this.#generateMatrixRows();\n    this.#sudokuRuleMatrix = this.#generateSudokuRuleMatrix();\n  }\n\n  /**\n   * Solves a sudoku by initializing the the recursive link dancing.\n   * Returns an array containing the rows that solve the array. It is fairly useless unless\n   * it is mapped to actual values.\n   */\n  solve(sudoku: (number | null)[][]) {\n    const sudokuRuleMatrixWithGivenNumbers = this.#applyGivenNumbersToRules(sudoku);\n    const linkedmatrix = new LinkedSparseMatrix(sudokuRuleMatrixWithGivenNumbers);\n    const solutions = [] as number[][];\n    const stack = [] as number[];\n\n    this.#recurse(linkedmatrix, solutions, stack);\n\n    return solutions;\n  }\n\n  /**\n   * Since a puzzle has clues, the entire matrix is not used.\n   * Only the rows that represent empty cells and given cells\n   * are included in the matrix that is represents the exact cover problem.\n   */\n  #applyGivenNumbersToRules(sudoku: (number | null)[][]): boolean[][] {\n    return this.#sudokuRuleMatrix.filter((r, i) => {\n      const metadata = this.#rowMetaData[i];\n      const cellValue = sudoku[metadata.row][metadata.column];\n      return cellValue === null || cellValue === metadata.value;\n    });\n  }\n\n  /**\n   * Implements the DLX algorithm, explained further here: https://arxiv.org/abs/cs/0011047\n   * In order to keep it stateless an array is passed around that includes all the found solutions.\n   * The current attempt is also passed around.\n   */\n  #recurse(linkedmatrix: LinkedSparseMatrix, solutions: number[][], currentAttempt: number[]): void {\n    const succeeded = linkedmatrix.Root.Right === linkedmatrix.Root;\n    if (succeeded) {\n      // TODO: Why sort?\n      solutions.push([...currentAttempt].sort());\n      return;\n    }\n\n    const bestColumn = this.#findBestColumnToStartAt(linkedmatrix.Root);\n    const failed = bestColumn.Size < 1;\n    if (failed) {\n      return;\n    }\n\n    const bestColumnIndex = linkedmatrix.getColumnIndexOf(bestColumn);\n    linkedmatrix.cover(bestColumnIndex);\n    for (let row = bestColumn.Down; row !== bestColumn; row = row.Down) {\n      currentAttempt.push(row.Y);\n      for (let entry = row.Right; entry !== row; entry = entry.Right) {\n        linkedmatrix.cover(entry.X);\n      }\n      this.#recurse(linkedmatrix, solutions, currentAttempt);\n      for (let entry = row.Left; entry !== row; entry = entry.Left) {\n        linkedmatrix.uncover(entry.X);\n      }\n      currentAttempt.pop();\n    }\n    linkedmatrix.uncover(bestColumnIndex);\n  }\n\n  /**\n   * The column used to start each itteration in the algorithm can be select anyway\n   * that I see fit. Knuth suggest selecting the column with the fewest entried so\n   * that is what I do here.\n   */\n  #findBestColumnToStartAt(root: MatrixEntry): MatrixEntry {\n    let bestColumn = root.Right;\n    for (let column = bestColumn.Right; column !== root; column = column.Right) {\n      if (column.Size < bestColumn.Size) {\n        bestColumn = column;\n      }\n    }\n    return bestColumn;\n  }\n\n  /**\n   * Generates a matrix based on the row metadata created earlier.\n   * The columns are crated from the restrictions that apply to a puzzle.\n   * 1) A cell can only contain a single value, represented by cellConstraints\n   * 2) A row can only contain a specific value once, represented by rowConstraints\n   * 3) A column can only contain a specific value, represented by columnConstraints\n   * 4) A block can only contain a specific value, represented by blockConstraints\n   */\n  #generateSudokuRuleMatrix(): boolean[][] {\n    return this.#rowMetaData.map((entry) => {\n      const cellConstraints = this.#getCellContraints(entry);\n      const rowContraints = this.#getRowContraints(entry);\n      const columnContraints = this.#getColumnConstraints(entry);\n      const blockConstraints = this.#getBlockConstraints(entry);\n      return [...cellConstraints, ...rowContraints, ...columnContraints, ...blockConstraints];\n    });\n  }\n\n  #getCellContraints(entry: metadata): boolean[] {\n    const result = [] as boolean[];\n    const cell = entry.row * 9 + entry.column;\n    for (let i = 0; i < 81; i++) {\n      result.push(i === cell);\n    }\n    return result;\n  }\n\n  #getRowContraints(entry: metadata): boolean[] {\n    const result = [] as boolean[];\n    for (let row = 0; row < 9; row++) {\n      for (let value = 1; value <= 9; value++) {\n        result.push(entry.value === value && entry.row === row);\n      }\n    }\n    return result;\n  }\n\n  #getColumnConstraints(entry: metadata): boolean[] {\n    const result = [] as boolean[];\n    for (let column = 0; column < 9; column++) {\n      for (let value = 1; value <= 9; value++) {\n        result.push(entry.value === value && entry.column === column);\n      }\n    }\n    return result;\n  }\n\n  #getBlockConstraints(entry: metadata): boolean[] {\n    const result = [] as boolean[];\n    for (let block = 0; block < 9; block++) {\n      for (let value = 1; value <= 9; value++) {\n        result.push(entry.value === value && entry.block === block);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Generates the rows that are used to create the matrix that is used to find\n   * an exact cover.The row metadata contains the row, columns, block and value\n   * of the cell in the sudoku. An entry represent the sudoku row column and\n   * value in all permutaions.\n   */\n  #generateMatrixRows(): metadata[] {\n    const result = [] as metadata[];\n    for (let row = 0; row < 9; row++) {\n      for (let column = 0; column < 9; column++) {\n        for (let value = 1; value <= 9; value++) {\n          const block = Math.floor(row / 3) * 3 + Math.floor(column / 3);\n          result.push({\n            row,\n            column,\n            block,\n            value,\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n","import { Solver } from '../validator/Solver';\n\nconst BASE = [\n  [3, 6, 1, 7, 2, 5, 9, 4, 8],\n  [5, 8, 7, 9, 6, 4, 2, 1, 3],\n  [4, 9, 2, 8, 3, 1, 6, 5, 7],\n  [6, 3, 8, 2, 5, 9, 4, 7, 1],\n  [1, 7, 4, 6, 8, 3, 5, 9, 2],\n  [2, 5, 9, 1, 4, 7, 8, 3, 6],\n  [7, 4, 6, 3, 9, 2, 1, 8, 5],\n  [9, 2, 3, 5, 1, 8, 7, 6, 4],\n  [8, 1, 5, 4, 7, 6, 3, 2, 9],\n];\n\n// prettier-ignore\nconst ALL_GIVEN: [number, number][] = [\n  [0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], \n  [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], \n  [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], \n  [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], \n  [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], \n  [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8], \n  [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8], \n  [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8], \n  [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8], \n];\n\nexport class Generator {\n  #solution: number[][];\n  #puzzle: (null | number)[][];\n  #given: [number, number][];\n\n  constructor() {\n    this.#solution = [];\n    this.#puzzle = [];\n    this.#given = [];\n  }\n\n  generate() {\n    const solver = new Solver();\n\n    // Reset internal state to make sure the generator is stateless\n    this.#solution = this.#shuffle(BASE);\n    this.#given = Array.from(ALL_GIVEN);\n    this.#puzzle = this.#solution.map((r) => [...r]);\n\n    // Allow only a few extra attempts as to prioritize failing early.\n    let allowedAttempts = 64 * 2;\n    while (allowedAttempts--) {\n      const candidates = this.#getCandicates();\n      const removed = [] as { value: number; row: number; column: number }[];\n      for (let i = 0; i < candidates.length; i++) {\n        const [row, column] = candidates[i];\n        const value = this.#puzzle[row][column] as number;\n        removed.push({\n          row,\n          column,\n          value,\n        });\n        this.#puzzle[row][column] = null;\n        this.#given = this.#given.filter((given) => !(given[0] === row && given[1] === column));\n      }\n      if (solver.solve(this.#puzzle).length !== 1) {\n        for (let i = 0; i < removed.length; i++) {\n          const { row, column, value } = removed[i];\n          this.#puzzle[row][column] = value;\n          this.#given.push([row, column]);\n        }\n        if (this.#given.length <= 28) {\n          break;\n        }\n      }\n    }\n\n    if (allowedAttempts > 0) {\n      return true;\n    } else {\n      this.#puzzle = [];\n      return false;\n    }\n  }\n\n  #getCandicates() {\n    const randomIndex = ~~(Math.random() * this.#given.length);\n    const firstCandidate = this.#given[randomIndex];\n    // When we have few cells left we only attempt a single candidate at a time.\n    if (this.#given.length <= 32) {\n      return [firstCandidate];\n    }\n\n    if (firstCandidate[0] === firstCandidate[1]) {\n      return [firstCandidate, [8 - firstCandidate[0], 8 - firstCandidate[1]]];\n    }\n\n    // TODO: Add additional symetries.\n    // TODO: Optimize initial candidates to remove four, needs benchmark.\n    return [firstCandidate, [firstCandidate[1], firstCandidate[0]]];\n  }\n\n  #shuffle(base: number[][]): number[][] {\n    const data = base.map((r) => [...r]);\n    for (let i = 0; i < 1000; i++) {\n      this.#moveRowOrColumn(data);\n    }\n    return data;\n  }\n\n  getPuzzleData(): { puzzle: string; solution: string } {\n    return {\n      puzzle: this.#puzzle\n        .flat()\n        .map((x) => x || 0)\n        .join(''),\n      solution: this.#solution\n        .flat()\n        .map((x) => x || 0)\n        .join(''),\n    };\n  }\n\n  #moveRowOrColumn(data: number[][]) {\n    const [from, to] = this.#getFromAndTo();\n    if (Math.round(Math.random())) {\n      this.#moveColumn(data, from, to);\n    } else {\n      this.#moveRow(data, from, to);\n    }\n  }\n\n  #getFromAndTo(from: number = -1): [number, number] {\n    from = from === -1 ? ~~(Math.random() * 3) : from;\n    const to = (from + Math.round(Math.random() * 2)) % 3;\n    const block = ~~(Math.random() * 3);\n    return [block * 3 + from, block * 3 + to];\n  }\n\n  #moveRow(data: number[][], from: number, to: number) {\n    const temp = data[to];\n    data[to] = data[from];\n    data[from] = temp;\n  }\n\n  #moveColumn(data: number[][], from: number, to: number) {\n    for (let i = 0; i < data.length; i++) {\n      const row = data[i];\n      const temp = row[to];\n      row[to] = row[from];\n      row[from] = temp;\n    }\n  }\n}\n","import { Generator } from '../sudoku/generator/Generator';\n\nself.onmessage = (event: { data: 'generate' }) => {\n  if (event.data === 'generate') {\n    run();\n  }\n};\n\nconst run = () => {\n  const generator = new Generator();\n  if (generator.generate()) {\n    const { puzzle } = generator.getPuzzleData();\n    self.postMessage({\n      puzzle,\n    });\n  } else {\n    self.postMessage('failed');\n  }\n};\n"],"names":["MatrixEntry","constructor","x","y","this","X","Y","Left","Right","Up","Down","Size","incrementSize","decrementSize","horizontalExclude","verticalExclude","horizontalInclude","verticalInclude","horizontalInsert","entry","verticalInsert","LinkedSparseMatrix","data","sparseRepresentation","getColumnIndexOf","columnHeader","indexOf","Root","map","row","reduce","sparse","value","index","push","cover","uncover","forEach","dataRow","i","temporaryRowRoot","dataPoint","length","currentColumnHeader","count","Solver","solve","sudoku","sudokuRuleMatrixWithGivenNumbers","linkedmatrix","solutions","filter","r","metadata","cellValue","column","currentAttempt","sort","bestColumn","bestColumnIndex","pop","root","result","cell","block","Math","floor","BASE","ALL_GIVEN","Generator","generate","solver","Array","from","allowedAttempts","candidates","removed","given","randomIndex","random","firstCandidate","base","getPuzzleData","puzzle","flat","join","solution","to","round","temp","self","onmessage","event","run","generator","postMessage"],"sourceRoot":""}