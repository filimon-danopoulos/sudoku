{"version":3,"file":"static/js/26.5f396730.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","models/Difficulty.ts","solver/MatrixEntry.ts","solver/LinkedMatrix.ts","solver/SudokuSolver.ts","models/Generator.ts","workers/GeneratePuzzle.worker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export enum DIFFICULTY {\r\n  VeryEasy = 30,\r\n  Easy = 36,\r\n  Normal = 42,\r\n  Hard = 50,\r\n  VeryHard = 57\r\n}\r\n","export default class MatrixEntry {\r\n  private size: number;\r\n  private left: MatrixEntry;\r\n  private right: MatrixEntry;\r\n  private up: MatrixEntry;\r\n  private down: MatrixEntry;\r\n\r\n  constructor(private x: number, private y: number) {\r\n    this.size = 0;\r\n\r\n    this.left = this;\r\n    this.right = this;\r\n    this.up = this;\r\n    this.down = this;\r\n  }\r\n\r\n  public get X(): number {\r\n    return this.x;\r\n  }\r\n\r\n  public get Y(): number {\r\n    return this.y;\r\n  }\r\n\r\n  public get Left(): MatrixEntry {\r\n    return this.left;\r\n  }\r\n\r\n  public get Right(): MatrixEntry {\r\n    return this.right;\r\n  }\r\n\r\n  public get Up(): MatrixEntry {\r\n    return this.up;\r\n  }\r\n\r\n  public get Down(): MatrixEntry {\r\n    return this.down;\r\n  }\r\n\r\n  public get Size(): number {\r\n    return this.size;\r\n  }\r\n\r\n  public incrementSize(): void {\r\n    ++this.size;\r\n  }\r\n\r\n  public decrementSize(): void {\r\n    --this.size;\r\n  }\r\n\r\n  public horizontalExclude(): void {\r\n    this.left.right = this.right;\r\n    this.right.left = this.left;\r\n  }\r\n\r\n  public verticalExclude(): void {\r\n    this.up.down = this.down;\r\n    this.down.up = this.up;\r\n  }\r\n\r\n  public horizontalInclude(): void {\r\n    this.left.right = this;\r\n    this.right.left = this;\r\n  }\r\n\r\n  public verticalInclude(): void {\r\n    this.up.down = this;\r\n    this.down.up = this;\r\n  }\r\n\r\n  public horizontalInsert(entry: MatrixEntry): void {\r\n    entry.left = this.left;\r\n    entry.right = this;\r\n\r\n    this.left.right = entry;\r\n    this.left = entry;\r\n  }\r\n\r\n  public verticalInsert(entry: MatrixEntry): void {\r\n    entry.up = this.up;\r\n    entry.down = this;\r\n\r\n    this.up.down = entry;\r\n    this.up = entry;\r\n  }\r\n}\r\n","import MatrixEntry from './MatrixEntry';\r\n\r\n/**\r\n * A sparse matrix where each element is douply linked in both the row and column direction.\r\n */\r\nexport default class LinkedSparseMatrix {\r\n  private root: MatrixEntry;\r\n  private columnHeaders: MatrixEntry[];\r\n\r\n  constructor(data: boolean[][]) {\r\n    this.root = new MatrixEntry(-1, -1);\r\n    this.columnHeaders = [];\r\n    const sparseRepresentation = this.convertDenseMatrixToSparseRepresentation(data);\r\n    this.generateRows(sparseRepresentation);\r\n  }\r\n\r\n  public getColumnIndexOf(columnHeader: MatrixEntry): number {\r\n    return this.columnHeaders.indexOf(columnHeader);\r\n  }\r\n\r\n  public get Root(): MatrixEntry {\r\n    return this.root;\r\n  }\r\n\r\n  /**\r\n   * Converts matrix of ones and zeroes where most elements are\r\n   * zeroes, i.e. a sparse matrix to a representation where each element\r\n   * correponds to the index of a one. This greatly reduces the ammount\r\n   * of elements we are required to keep track of.\r\n   */\r\n  private convertDenseMatrixToSparseRepresentation(data: boolean[][]): number[][] {\r\n    return data.map(\r\n      row =>\r\n        row.reduce(\r\n          (sparse, value, index) => {\r\n            if (value) {\r\n              sparse.push(index);\r\n            }\r\n            return sparse;\r\n          },\r\n          [] as number[]\r\n        ),\r\n      [] as number[][]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * All rows that have an entry at the provided column index are excluded from the linked matrix.\r\n   * They are not removed from the columns array so that they can be added gain.\r\n   * This is made possible by the way the data in structured. An entry is linked to a column\r\n   * header only if it has an entry in the corresponding column. By itterating through\r\n   * the Down link all rows can be found. All entries in the entrire row can then\r\n   * be found and excluded through the Right link.\r\n   */\r\n  public cover(index: number): void {\r\n    const columnHeader = this.columnHeaders[index];\r\n\r\n    columnHeader.horizontalExclude();\r\n    for (let row = columnHeader.Down; row !== columnHeader; row = row.Down) {\r\n      for (let entry = row.Right; entry !== row; entry = entry.Right) {\r\n        entry.verticalExclude();\r\n        this.columnHeaders[entry.X].decrementSize();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * All rows that have an entry at the provided column index are included in the linked matrix.\r\n   * The same approach is taken as in the cover method but the Up and Left are used instead.\r\n   * That way the original order is maintained.\r\n   */\r\n  public uncover(index: number): void {\r\n    const columnHeader = this.columnHeaders[index];\r\n\r\n    columnHeader.horizontalInclude();\r\n    for (let row = columnHeader.Up; row !== columnHeader; row = row.Up) {\r\n      for (let entry = row.Left; entry !== row; entry = entry.Left) {\r\n        entry.verticalInclude();\r\n        this.columnHeaders[entry.X].incrementSize();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates each row of the data. Each row is built on temporary entry that is later removed.\r\n   * Each element in each row is also linked to a column. This methods makes sure that\r\n   * all required column headers exist. By linking the entries in both the row and column\r\n   * direction the time it takes to traverse the matrix to find ones is greatly reduced.\r\n   */\r\n  private generateRows(sparseRepresentation: number[][]) {\r\n    sparseRepresentation.forEach((dataRow, i) => {\r\n      const temporaryRowRoot = new MatrixEntry(-1, i);\r\n      dataRow.forEach(dataPoint => {\r\n        const entry = new MatrixEntry(dataPoint, i);\r\n\r\n        if (this.columnHeaders.length <= dataPoint) {\r\n          this.appendColumnHeaders(dataPoint - this.columnHeaders.length + 1);\r\n        }\r\n        const currentColumnHeader = this.columnHeaders[dataPoint];\r\n        currentColumnHeader.verticalInsert(entry);\r\n        currentColumnHeader.incrementSize();\r\n        temporaryRowRoot.horizontalInsert(entry);\r\n      });\r\n      temporaryRowRoot.horizontalExclude();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Appends new MatrixEntries called headers (they are not part of the data).\r\n   * These linked to the root element, each element in a row is also part of a linked list that\r\n   * is based of a column header.\r\n   */\r\n  private appendColumnHeaders(count: number): void {\r\n    while (count--) {\r\n      const columnHeader = new MatrixEntry(this.columnHeaders.length, -1);\r\n      this.root.horizontalInsert(columnHeader);\r\n      this.columnHeaders.push(columnHeader);\r\n    }\r\n  }\r\n}\r\n","import LinkedSparseMatrix from './LinkedMatrix';\r\nimport MatrixEntry from './MatrixEntry';\r\n\r\ntype metadata = {\r\n  row: number;\r\n  column: number;\r\n  block: number;\r\n  value: number;\r\n};\r\n\r\n/**\r\n * A solver that uses DLX to solve puzzles. It is expensive to initialize.\r\n * However it is stateless so once it has been initialized it can be be used to solve many puzzles.\r\n */\r\nexport default class SudokuSolver {\r\n  private rowMetaData: metadata[];\r\n  private sudokuRuleMatrix: boolean[][];\r\n\r\n  constructor() {\r\n    this.rowMetaData = this.generateMatrixRows();\r\n    this.sudokuRuleMatrix = this.generateSudokuRuleMatrix();\r\n  }\r\n\r\n  /**\r\n   * Solves a sudoku by initializing the the recursive link dancing.\r\n   * Returns an array containing the rows that solve the array. It is fairly useless unless\r\n   * it is mapped to actual values.\r\n   */\r\n  public solve(sudoku: (number | null)[][]): number[][] {\r\n    const sudokuRuleMatrixWithGivenNumbers = this.applyGivenNumbersToRules(sudoku);\r\n    const linkedmatrix = new LinkedSparseMatrix(sudokuRuleMatrixWithGivenNumbers);\r\n    const solutions = [] as number[][];\r\n    const stack = [] as number[];\r\n\r\n    this.recurse(linkedmatrix, solutions, stack);\r\n\r\n    return solutions;\r\n  }\r\n\r\n  /**\r\n   * Since a puzzle has clues, the entire matrix is not used.\r\n   * Only the rows that represent empty cells and given cells\r\n   * are included in the matrix that is represents the exact cover problem.\r\n   */\r\n  private applyGivenNumbersToRules(sudoku: (number | null)[][]): boolean[][] {\r\n    return this.sudokuRuleMatrix.filter((r, i) => {\r\n      const metadata = this.rowMetaData[i];\r\n      const cellValue = sudoku[metadata.row][metadata.column];\r\n      return cellValue === null || cellValue === metadata.value;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Implements the DLX algorithm, explained further here: https://arxiv.org/abs/cs/0011047\r\n   * In order to keep it stateless an array is passed around that includes all the found solutions.\r\n   * The current attempt is also passed around.\r\n   */\r\n  private recurse(\r\n    linkedmatrix: LinkedSparseMatrix,\r\n    solutions: number[][],\r\n    currentAttempt: number[]\r\n  ): void {\r\n    const succeeded = linkedmatrix.Root.Right === linkedmatrix.Root;\r\n    if (succeeded) {\r\n      solutions.push([...currentAttempt].sort());\r\n      return;\r\n    }\r\n\r\n    const bestColumn = this.findBestColumnToStartAt(linkedmatrix.Root);\r\n    const failed = bestColumn.Size < 1;\r\n    if (failed) {\r\n      return;\r\n    }\r\n\r\n    const bestColumnIndex = linkedmatrix.getColumnIndexOf(bestColumn);\r\n    linkedmatrix.cover(bestColumnIndex);\r\n    for (let row = bestColumn.Down; row !== bestColumn; row = row.Down) {\r\n      currentAttempt.push(row.Y);\r\n      for (let entry = row.Right; entry !== row; entry = entry.Right) {\r\n        linkedmatrix.cover(entry.X);\r\n      }\r\n      this.recurse(linkedmatrix, solutions, currentAttempt);\r\n      for (let entry = row.Left; entry !== row; entry = entry.Left) {\r\n        linkedmatrix.uncover(entry.X);\r\n      }\r\n      currentAttempt.pop();\r\n    }\r\n    linkedmatrix.uncover(bestColumnIndex);\r\n  }\r\n\r\n  /**\r\n   * The column used to start each itteration in the algorithm can be select anyway\r\n   * that I see fit. Knuth suggest selecting the column with the fewest entried so\r\n   * that is what I do here.\r\n   */\r\n  private findBestColumnToStartAt(root: MatrixEntry): MatrixEntry {\r\n    let bestColumn = root.Right;\r\n    for (let column = bestColumn.Right; column !== root; column = column.Right) {\r\n      if (column.Size < bestColumn.Size) {\r\n        bestColumn = column;\r\n      }\r\n    }\r\n    return bestColumn;\r\n  }\r\n\r\n  /**\r\n   * Generates a matrix based on the row metadata created earlier.\r\n   * The columns are crated from the restrictions that apply to a puzzle.\r\n   * 1) A cell can only contain a single value, represented by cellConstraints\r\n   * 2) A row can only contain a specific value once, represented by rowConstraints\r\n   * 3) A column can only contain a specific value, represented by columnConstraints\r\n   * 4) A block can only contain a specific value, represented by blockConstraints\r\n   */\r\n  private generateSudokuRuleMatrix(): boolean[][] {\r\n    return this.rowMetaData.map(entry => {\r\n      const cellConstraints = this.getCellContraints(entry);\r\n      const rowContraints = this.getRowContraints(entry);\r\n      const columnContraints = this.getColumnConstraints(entry);\r\n      const blockConstraints = this.getBlockConstraints(entry);\r\n      return [...cellConstraints, ...rowContraints, ...columnContraints, ...blockConstraints];\r\n    });\r\n  }\r\n  private getCellContraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    const cell = entry.row * 9 + entry.column;\r\n    for (let i = 0; i < 81; i++) {\r\n      result.push(i === cell);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getRowContraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    for (let row = 0; row < 9; row++) {\r\n      for (let value = 1; value <= 9; value++) {\r\n        result.push(entry.value === value && entry.row === row);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getColumnConstraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    for (let column = 0; column < 9; column++) {\r\n      for (let value = 1; value <= 9; value++) {\r\n        result.push(entry.value === value && entry.column === column);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private getBlockConstraints(entry: metadata): boolean[] {\r\n    const result = [] as boolean[];\r\n    for (let block = 0; block < 9; block++) {\r\n      for (let value = 1; value <= 9; value++) {\r\n        result.push(entry.value === value && entry.block === block);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates the rows that are used to create the matrix that is used to find\r\n   * an exact cover.The row metadata contains the row, columns, block and value\r\n   * of the cell in the sudoku. An entry represent the sudoku row column and\r\n   * value in all permutaions.\r\n   */\r\n  private generateMatrixRows(): metadata[] {\r\n    const result = [] as metadata[];\r\n    for (let row = 0; row < 9; row++) {\r\n      for (let column = 0; column < 9; column++) {\r\n        for (let value = 1; value <= 9; value++) {\r\n          const block = Math.floor(row / 3) * 3 + Math.floor(column / 3);\r\n          result.push({\r\n            row,\r\n            column,\r\n            block,\r\n            value\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n","import { DIFFICULTY } from './Difficulty';\r\nimport SudokuSolver from '../solver/SudokuSolver';\r\n\r\nconst BASE = [\r\n  [3, 6, 1, 7, 2, 5, 9, 4, 8],\r\n  [5, 8, 7, 9, 6, 4, 2, 1, 3],\r\n  [4, 9, 2, 8, 3, 1, 6, 5, 7],\r\n  [6, 3, 8, 2, 5, 9, 4, 7, 1],\r\n  [1, 7, 4, 6, 8, 3, 5, 9, 2],\r\n  [2, 5, 9, 1, 4, 7, 8, 3, 6],\r\n  [7, 4, 6, 3, 9, 2, 1, 8, 5],\r\n  [9, 2, 3, 5, 1, 8, 7, 6, 4],\r\n  [8, 1, 5, 4, 7, 6, 3, 2, 9]\r\n];\r\n\r\nexport default class Generator {\r\n  private solution: number[][];\r\n  private data: (null | number)[][];\r\n\r\n  constructor(private difficulty: DIFFICULTY) {\r\n    this.solution = this.shuffle(BASE);\r\n    this.data = [];\r\n  }\r\n\r\n  public generate() {\r\n    const solver = new SudokuSolver();\r\n    const startAt = Date.now();\r\n    this.data = this.solution.map(r => [...r]);\r\n    const removed = [] as string[];\r\n    let allowedAttempts = 1273;\r\n    while (removed.length < this.difficulty && allowedAttempts--) {\r\n      let row;\r\n      let column;\r\n      do {\r\n        row = ~~(Math.random() * 9);\r\n        column = ~~(Math.random() * 9);\r\n      } while (removed.includes(`${row}:${column}`));\r\n      let value = this.data[row][column];\r\n      this.data[row][column] = null;\r\n      const solutions = solver.solve(this.data);\r\n      if (solutions.length === 1) {\r\n        removed.push(`${row}:${column}`);\r\n      } else {\r\n        this.data[row][column] = value;\r\n      }\r\n    }\r\n    const ellapsedTime = Date.now() - startAt;\r\n\r\n    if (allowedAttempts > 0) {\r\n      console.log(`It took ${ellapsedTime}ms to generate a ${DIFFICULTY[this.difficulty]} puzzle`);\r\n      return true;\r\n    } else {\r\n      console.log(\r\n        `Failed to generate a ${DIFFICULTY[this.difficulty]} puzzle after ${ellapsedTime}ms`\r\n      );\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private shuffle(base: number[][]): number[][] {\r\n    const data = BASE.map(r => [...r]);\r\n    for (let i = 0; i < 4200; i++) {\r\n      this.moveRowOrColumn(data);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  public getPuzzleData(): ([number, boolean])[][] {\r\n    return this.data.map((r, i) =>\r\n      r.map(\r\n        (y, l) =>\r\n          [this.solution[i][l], this.solution[i][l] === this.data[i][l]] as [number, boolean]\r\n      )\r\n    );\r\n  }\r\n\r\n  private moveRowOrColumn(data: number[][]) {\r\n    const [from, to] = this.getFromAndTo();\r\n    if (!!Math.round(Math.random())) {\r\n      this.moveColumn(data, from, to);\r\n    } else {\r\n      this.moveRow(data, from, to);\r\n    }\r\n  }\r\n\r\n  private getFromAndTo(from: number = -1): [number, number] {\r\n    from = from === -1 ? Math.floor(Math.random() * 3) : from;\r\n    let to = ~~(Math.random() * 3);\r\n    if (to === from) {\r\n      return this.getFromAndTo(from);\r\n    }\r\n    const block = ~~(Math.random() * 3);\r\n    return [block * 3 + from, block * 3 + to];\r\n  }\r\n\r\n  private moveRow(data: number[][], from: number, to: number) {\r\n    const temp = data[to];\r\n    data[to] = data[from];\r\n    data[from] = temp;\r\n  }\r\n\r\n  private moveColumn(data: number[][], from: number, to: number) {\r\n    data.forEach(row => {\r\n      const temp = row[to];\r\n      row[to] = row[from];\r\n      row[from] = temp;\r\n    });\r\n  }\r\n}\r\n","import Generator from '../models/Generator';\r\nimport { DIFFICULTY } from '../models/Difficulty';\r\n\r\n// eslint-disable-next-line no-restricted-globals\r\nconst ctx: Worker = self as any;\r\n\r\nctx.addEventListener('message', message => {\r\n  const difficulty = message.data as DIFFICULTY;\r\n  const puzzleData = runGenerator(difficulty);\r\n  ctx.postMessage({\r\n    puzzleData,\r\n    difficulty,\r\n  });\r\n});\r\n\r\nfunction runGenerator(difficulty: DIFFICULTY): [number, boolean][][] {\r\n  let tries = 10;\r\n  do {\r\n    const generator = new Generator(difficulty);\r\n    if (generator.generate()) {\r\n      return generator.getPuzzleData();\r\n    }\r\n  } while (--tries);\r\n  throw new Error('Could not generate puzzle.');\r\n}\r\n\r\nexport default null as any;\r\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_toConsumableArray","iter","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","DIFFICULTY","MatrixEntry","x","y","size","left","right","up","down","this","entry","LinkedSparseMatrix","data","root","columnHeaders","sparseRepresentation","convertDenseMatrixToSparseRepresentation","generateRows","columnHeader","indexOf","map","row","reduce","sparse","index","horizontalExclude","Down","Right","verticalExclude","X","decrementSize","horizontalInclude","Up","Left","verticalInclude","incrementSize","forEach","dataRow","temporaryRowRoot","dataPoint","appendColumnHeaders","currentColumnHeader","verticalInsert","horizontalInsert","count","SudokuSolver","rowMetaData","sudokuRuleMatrix","generateMatrixRows","generateSudokuRuleMatrix","sudoku","sudokuRuleMatrixWithGivenNumbers","applyGivenNumbersToRules","linkedmatrix","solutions","recurse","filter","r","metadata","cellValue","column","currentAttempt","Root","sort","bestColumn","findBestColumnToStartAt","Size","bestColumnIndex","getColumnIndexOf","cover","Y","uncover","pop","cellConstraints","getCellContraints","rowContraints","getRowContraints","columnContraints","getColumnConstraints","blockConstraints","getBlockConstraints","result","cell","block","Math","floor","BASE","Generator","difficulty","solution","shuffle","solver","startAt","Date","now","removed","allowedAttempts","random","includes","solve","ellapsedTime","console","log","base","moveRowOrColumn","l","getFromAndTo","to","round","moveColumn","moveRow","temp","ctx","self","addEventListener","message","puzzleData","tries","generator","generate","getPuzzleData","Error","runGenerator","postMessage"],"sourceRoot":""}